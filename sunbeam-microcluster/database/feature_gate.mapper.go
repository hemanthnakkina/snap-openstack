package database

// The code below was generated by lxd-generate - DO NOT EDIT!

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"net/http"

	"github.com/canonical/lxd/lxd/db/query"
	"github.com/canonical/lxd/shared/api"
	"github.com/canonical/microcluster/v2/cluster"
)

var _ = api.ServerEnvironment{}

var featureGateObjects = cluster.RegisterStmt(`
SELECT feature_gates.id, feature_gates.gate_key, feature_gates.enabled
  FROM feature_gates
  ORDER BY feature_gates.gate_key
`)

var featureGateObjectsByGateKey = cluster.RegisterStmt(`
SELECT feature_gates.id, feature_gates.gate_key, feature_gates.enabled
  FROM feature_gates
  WHERE ( feature_gates.gate_key = ? )
  ORDER BY feature_gates.gate_key
`)

var featureGateID = cluster.RegisterStmt(`
SELECT feature_gates.id FROM feature_gates
  WHERE feature_gates.gate_key = ?
`)

var featureGateCreate = cluster.RegisterStmt(`
INSERT INTO feature_gates (gate_key, enabled)
  VALUES (?, ?)
`)

var featureGateDeleteByGateKey = cluster.RegisterStmt(`
DELETE FROM feature_gates WHERE gate_key = ?
`)

var featureGateUpdate = cluster.RegisterStmt(`
UPDATE feature_gates
  SET gate_key = ?, enabled = ?
 WHERE id = ?
`)

// GetFeatureGates returns all available FeatureGates.
func GetFeatureGates(ctx context.Context, tx *sql.Tx) ([]FeatureGate, error) {
	objects := make([]FeatureGate, 0)

	stmt, err := cluster.Stmt(tx, featureGateObjects)
	if err != nil {
		return nil, fmt.Errorf("Failed to get \"featureGateObjects\" prepared statement: %w", err)
	}

	dest := func(scan func(dest ...any) error) error {
		f := FeatureGate{}
		err := scan(&f.ID, &f.GateKey, &f.Enabled)
		if err != nil {
			return err
		}

		objects = append(objects, f)
		return nil
	}

	err = query.SelectObjects(ctx, stmt, dest)
	if err != nil {
		return nil, fmt.Errorf("Failed to fetch from \"feature_gates\" table: %w", err)
	}

	return objects, nil
}

// GetFeatureGate returns a single FeatureGate by gate_key.
func GetFeatureGate(ctx context.Context, tx *sql.Tx, gateKey string) (FeatureGate, error) {
	stmt, err := cluster.Stmt(tx, featureGateObjectsByGateKey)
	if err != nil {
		return FeatureGate{}, fmt.Errorf("Failed to get \"featureGateObjectsByGateKey\" prepared statement: %w", err)
	}

	var object FeatureGate
	dest := func(scan func(dest ...any) error) error {
		return scan(&object.ID, &object.GateKey, &object.Enabled)
	}

	err = query.SelectObjects(ctx, stmt, dest, gateKey)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return FeatureGate{}, api.StatusErrorf(http.StatusNotFound, "FeatureGate not found")
		}
		return FeatureGate{}, fmt.Errorf("Failed to fetch from \"feature_gates\" table: %w", err)
	}

	return object, nil
}

// CreateFeatureGate creates a new FeatureGate.
func CreateFeatureGate(ctx context.Context, tx *sql.Tx, object FeatureGate) (int64, error) {
	stmt, err := cluster.Stmt(tx, featureGateCreate)
	if err != nil {
		return -1, fmt.Errorf("Failed to get \"featureGateCreate\" prepared statement: %w", err)
	}

	result, err := stmt.Exec(object.GateKey, object.Enabled)
	if err != nil {
		return -1, fmt.Errorf("Failed to create \"feature_gates\" entry: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return -1, fmt.Errorf("Failed to fetch \"feature_gates\" entry ID: %w", err)
	}

	return id, nil
}

// DeleteFeatureGate deletes a FeatureGate by gate_key.
func DeleteFeatureGate(ctx context.Context, tx *sql.Tx, gateKey string) error {
	stmt, err := cluster.Stmt(tx, featureGateDeleteByGateKey)
	if err != nil {
		return fmt.Errorf("Failed to get \"featureGateDeleteByGateKey\" prepared statement: %w", err)
	}

	result, err := stmt.Exec(gateKey)
	if err != nil {
		return fmt.Errorf("Failed to delete \"feature_gates\" entry: %w", err)
	}

	n, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("Failed to fetch affected rows count: %w", err)
	}
	if n == 0 {
		return api.StatusErrorf(http.StatusNotFound, "FeatureGate not found")
	} else if n > 1 {
		return fmt.Errorf("Query deleted %d FeatureGate entries instead of 1", n)
	}

	return nil
}

// UpdateFeatureGate updates a FeatureGate.
func UpdateFeatureGate(ctx context.Context, tx *sql.Tx, gateKey string, object FeatureGate) error {
	id, err := GetFeatureGateID(ctx, tx, gateKey)
	if err != nil {
		return err
	}

	stmt, err := cluster.Stmt(tx, featureGateUpdate)
	if err != nil {
		return fmt.Errorf("Failed to get \"featureGateUpdate\" prepared statement: %w", err)
	}

	result, err := stmt.Exec(object.GateKey, object.Enabled, id)
	if err != nil {
		return fmt.Errorf("Failed to update \"feature_gates\" entry: %w", err)
	}

	n, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("Failed to fetch affected rows count: %w", err)
	}
	if n == 0 {
		return api.StatusErrorf(http.StatusNotFound, "FeatureGate not found")
	} else if n > 1 {
		return fmt.Errorf("Query updated %d FeatureGate entries instead of 1", n)
	}

	return nil
}

// GetFeatureGateID returns the ID of a FeatureGate by gate_key.
func GetFeatureGateID(ctx context.Context, tx *sql.Tx, gateKey string) (int64, error) {
	stmt, err := cluster.Stmt(tx, featureGateID)
	if err != nil {
		return -1, fmt.Errorf("Failed to get \"featureGateID\" prepared statement: %w", err)
	}

	row := stmt.QueryRowContext(ctx, gateKey)
	var id int64
	err = row.Scan(&id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return -1, api.StatusErrorf(http.StatusNotFound, "FeatureGate not found")
		}
		return -1, fmt.Errorf("Failed to get \"feature_gates\" ID: %w", err)
	}

	return id, nil
}

// FeatureGateExists checks if a FeatureGate exists by gate_key.
func FeatureGateExists(ctx context.Context, tx *sql.Tx, gateKey string) (bool, error) {
	_, err := GetFeatureGateID(ctx, tx, gateKey)
	if err != nil {
		if api.StatusErrorCheck(err, http.StatusNotFound) {
			return false, nil
		}
		return false, err
	}

	return true, nil
}
